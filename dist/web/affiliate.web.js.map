{"version":3,"file":"affiliate.web.js","mappings":"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","sources":["webpack://Affiliate/../src/Affiliate.ts","webpack://Affiliate/../src/index.ts","webpack://Affiliate/../src/shared/autoConfig.ts","webpack://Affiliate/../src/shared/features.ts","webpack://Affiliate/../src/shared/log.ts","webpack://Affiliate/../src/shared/nodeTools.ts","webpack://Affiliate/webpack/bootstrap","webpack://Affiliate/webpack/startup"],"sourcesContent":["import { hasMutationObserver, hasURL } from './shared/features';\nimport Log from './shared/log';\nimport { getNodeData, setNodeData } from './shared/nodeTools';\n\nexport interface AffiliateConfigTag {\n  hosts: string | string[];\n  query?: { [key: string]: string };\n  replace?: {\n    to: string;\n    from: string;\n  }[];\n  modify?: (url: URL) => URL | string;\n}\n\nexport interface AffiliateConfig {\n  tags: AffiliateConfigTag[];\n  log?: boolean;\n}\n\n/**\n * @class Manages stateful affiliation\n */\nclass Affiliate {\n  state: {\n    attached: boolean;\n    config: AffiliateConfig;\n    hosts: string[];\n  } = {\n    attached: false,\n    config: {\n      tags: [],\n    },\n    hosts: [],\n  };\n  observer: MutationObserver | undefined = undefined;\n  log: typeof Log;\n\n  constructor(config?: Partial<AffiliateConfig>) {\n    // Extend the configuration\n    config = config ?? {};\n    config.tags = config.tags ?? [];\n\n    config.tags.map((tag, i) => {\n      if (!config || !config.tags) return;\n\n      // Convert a single host to an array\n      if (typeof tag.hosts === 'string') tag.hosts = [tag.hosts];\n\n      // Extend proper tag configuration\n      config.tags[i] = {\n        query: {},\n        replace: [],\n        ...tag,\n      };\n\n      // Append hosts to full list\n      this.state.hosts = [\n        ...this.state.hosts,\n        ...(<string[]>config.tags[i].hosts),\n      ];\n    });\n\n    // Set logging function\n    this.log = config.log ? Log : () => undefined;\n\n    this.log(false, 'New Instance', config);\n\n    // Check is MutationObserver is supported\n    if (hasMutationObserver) {\n      // Initialize MutationObserver\n      this.observer = new window.MutationObserver((mutations) => {\n        // This function is called for every DOM mutation\n\n        // Has a mutation been logged\n        let emitted = false;\n\n        mutations.forEach((mutation) => {\n          // If the attributes of the link have been modified\n          if (mutation.type === 'attributes') {\n            // Skip links without an href\n            if (mutation.attributeName !== 'href') return;\n\n            const href = (<HTMLAnchorElement>mutation.target).href;\n            const linkData = getNodeData(mutation.target);\n\n            // Skip links without a modified href\n            if (linkData.is && linkData.is === href) return;\n          }\n\n          // Only calls on first mutation\n          if (!emitted) {\n            this.log(false, 'DOM Mutation', mutation);\n            emitted = true;\n          }\n\n          // Scan the node and subnodes if there are any\n          this.traverse(<HTMLElement>mutation.target);\n        });\n      });\n    }\n\n    // Set internal state\n    this.state.config = <AffiliateConfig>config;\n  }\n\n  /**\n   * Manual function to search the DOM for unaffiliated links\n   *\n   * @function\n   * @param {object=} nodeSet The node to traverse for links (default: document.body)\n   */\n  traverse(nodeSet: HTMLElement = document.body): Affiliate {\n    if (\n      typeof nodeSet !== 'object' ||\n      typeof nodeSet.getElementsByTagName !== 'function'\n    )\n      return this;\n\n    if (!hasURL) {\n      this.log(true, 'This browser needs a URL polyfill.');\n      return this;\n    }\n\n    this.log(false, 'Traversing DOM...');\n\n    // Reduce link collection to array\n    const collection = nodeSet.getElementsByTagName('a');\n    let nodes = <HTMLElement[]>Object.values(collection);\n\n    // If the nodeSet is a single link, turn to array\n    if (nodeSet.nodeName.toLowerCase() === 'a') nodes = [nodeSet];\n\n    this.log(false, `Found ${nodes.length + 1} nodes...`);\n\n    // Go through each link\n    nodes.forEach((node) => {\n      // Check if it is actually linking\n      if (!node || !('href' in node)) return;\n\n      // Parse the URL natively\n      const url = new URL(\n        (<HTMLAnchorElement>node).href ?? '',\n        window?.location.origin,\n      );\n\n      // Only modify hosts provided.\n      if (this.state.hosts.indexOf(url.host) === -1) return;\n      this.state.config.tags.forEach((tag) => {\n        if (tag.hosts.indexOf(url.host) !== -1) {\n          this.modifyURL(url, <HTMLAnchorElement>node, tag);\n        }\n      });\n    });\n\n    return this;\n  }\n\n  /**\n   * Modify the URL of a matching link while preserving the original link state\n   *\n   * @private\n   * @function\n   * @param {string} url Original url string\n   * @param {object} node Anchor link node\n   * @param {object} tag Matching configuration tag\n   */\n  modifyURL = (url: URL, node: HTMLAnchorElement, tag: AffiliateConfigTag) => {\n    // Check if URL is already modified\n    const linkData = getNodeData(node);\n    if (linkData.is && linkData.is === url.href) return;\n\n    // Preserve the original URL\n    const originalURL = url.href;\n\n    this.log(false, 'Discovered URL: ' + url.href);\n\n    // Change query variables\n    if (tag.query) {\n      Object.keys(tag.query ?? {}).forEach((key) => {\n        if (typeof tag.query === 'object')\n          url.searchParams.set(key, tag.query[key]);\n      });\n    }\n\n    // Run the modification function\n    if (typeof tag.modify === 'function') {\n      try {\n        let returnedURL = tag.modify(url);\n        if (typeof returnedURL === 'object') returnedURL = returnedURL.href;\n        url = new URL(returnedURL, window?.location.origin);\n      } catch (e) {\n        Log(true, e as Error);\n      }\n    }\n\n    // Replace certain parts of the url\n    let modifiedUrl = url.href;\n    tag.replace?.forEach((replacement) => {\n      modifiedUrl = modifiedUrl.replace(replacement.from, replacement.to);\n    });\n\n    // Update the href tag and save the url to the DOM node\n    node.href = modifiedUrl;\n    setNodeData(node, {\n      was: originalURL,\n      is: url.href,\n    });\n  };\n\n  /**\n   * Attach the mutation observer\n   *\n   * @function\n   */\n  attach = (): Affiliate => {\n    // Cannot attach twice, cannot attach for node\n    if (this.state.attached || typeof document === 'undefined') return this;\n\n    // Get readyState, or the loading state of the DOM\n    const { readyState } = document;\n\n    if (readyState === 'complete' || readyState === 'interactive') {\n      // Set attached to true\n      this.state.attached = true;\n\n      // Run through the entire body tag\n      this.traverse();\n\n      if (hasMutationObserver && this.observer) {\n        // Attach the observer\n        this.observer.observe(document.body, {\n          childList: true,\n          subtree: true,\n          attributes: true,\n          characterData: true,\n          attributeFilter: ['href'],\n        });\n      } else {\n        this.log(false, 'Browser does not support MutationObserver.');\n      }\n    } else {\n      // Wait until the DOM loads\n      window.addEventListener('DOMContentLoaded', this.attach);\n    }\n\n    return this;\n  };\n\n  /**\n   * Detach the mutation observer\n   *\n   * @function\n   */\n  detach = (): Affiliate => {\n    if (!hasMutationObserver || !this.observer) return this;\n    this.state.attached = false;\n    this.observer.disconnect();\n    this.log(false, 'Observer disconnected.');\n    return this;\n  };\n}\n\nexport default Affiliate;\n","import AutoConfig from './shared/autoConfig';\nimport Affiliate, { AffiliateConfig } from './Affiliate';\nimport Log from './shared/log';\nimport { getNodeData, setNodeData } from './shared/nodeTools';\n\n/**\n * @class Set up the global Affiliate export\n */\nclass Generator {\n  state: {\n    instances: Affiliate[];\n    auto?: Affiliate;\n  } = {\n    instances: [],\n  };\n\n  constructor() {\n    try {\n      const config = AutoConfig();\n      if (typeof config === 'object') {\n        const auto = this.create(config);\n        Log(false, auto);\n        this.state.auto = auto;\n        auto.attach();\n      }\n    } catch (e) {\n      Log(true, e as Error);\n    }\n  }\n\n  /**\n   * Create a new Affiliate instance\n   *\n   * @function\n   * @param {object} config Configuration options for Affiliate\n   * @returns {object} Affiliate instance\n   */\n  create = (config: Partial<AffiliateConfig>) => {\n    const Instance = new Affiliate(config);\n    this.state.instances.push(Instance);\n    return Instance;\n  };\n\n  /**\n   * Expose the instance list\n   *\n   * @type {Array.<object>}\n   */\n  get instances() {\n    return [...this.state.instances];\n  }\n\n  /**\n   * Detach automatic link traversal\n   *\n   * @function\n   */\n  detachAll = () => {\n    this.state.instances.forEach((instance) => instance.detach());\n  };\n\n  /**\n   * Revert all traversed links to their non-affiliated state\n   *\n   * @function\n   */\n  revert = () => {\n    this.detachAll();\n    const nodes = Object.values(document.body.getElementsByTagName('a'));\n    nodes.forEach((node) => {\n      const linkData = getNodeData(node);\n      if (linkData && typeof linkData.was === 'string') {\n        node.href = linkData.was;\n        setNodeData(node, {});\n      }\n    });\n  };\n}\n\nexport default new Generator();\n","const AUTO_CONFIG_SYNTAX_REGEX = /WHERE (.+?) SET (.+?)\\s*(?:AND|$)/g;\n\n/* Setup automatic configuration */\nconst AutoConfig = () => {\n  const scriptNode = document.getElementById('aff-js');\n\n  if (typeof scriptNode === 'object' && scriptNode) {\n    const nodeData = scriptNode?.dataset?.autoAffiliate;\n\n    if (typeof nodeData === 'string') {\n      const tags: { hosts: string[]; query: Record<string, string> }[] = [];\n\n      const expressions = nodeData.match(AUTO_CONFIG_SYNTAX_REGEX);\n\n      if (!expressions) return;\n\n      Object.values(expressions).forEach((expression) => {\n        const components = AUTO_CONFIG_SYNTAX_REGEX.exec(expression);\n\n        if (!components || components.length !== 3) return;\n\n        const hosts = components[1];\n        const queries = components[2];\n\n        tags.push({\n          hosts: hosts.split(',').map((host) => host.trim()),\n          query: queries.split(',').reduce((a, b) => {\n            const [key, value] = b.split('=');\n            if (key && value) a[key.trim()] = value.trim();\n            return a;\n          }, {} as Record<string, string>),\n        });\n      });\n\n      return { tags };\n    }\n  }\n};\n\nexport default AutoConfig;\n","// Check for MutationObserver\nexport const hasMutationObserver =\n  typeof window === 'object' &&\n  !(typeof window.MutationObserver === 'undefined');\n\n// Check for URL and URLSearchParams\nexport const hasURL =\n  typeof URL === 'function' && typeof URLSearchParams === 'function';\n","/**\n * log handles formatting and doesn't throw errors is console is undefined\n *\n * @module affiliate/src/Log\n */\nexport default function (\n  isError: boolean,\n  ...args: (string | number | object)[]\n) {\n  const textId = '[Affiliate] ';\n\n  if (typeof console === 'object') {\n    if (isError) {\n      console.error(textId, ...args);\n    } else {\n      console.log(textId, ...args);\n    }\n  }\n}\n","const NODE_DATA_KEY = '_aff';\n\ntype DataNode = Node & { [NODE_DATA_KEY]?: Record<string, string> };\n\nexport const getNodeData = (node: DataNode): Record<string, string> => {\n  return node[NODE_DATA_KEY] ?? {};\n};\n\nexport const setNodeData = (\n  node: DataNode,\n  data: Record<string, string>,\n): void => {\n  Object.assign(node, { [NODE_DATA_KEY]: data });\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(309);\n"],"names":["Affiliate","config","state","attached","tags","hosts","observer","undefined","modifyURL","url","node","tag","linkData","getNodeData","is","href","originalURL","log","query","Object","keys","forEach","key","searchParams","set","modify","returnedURL","URL","window","location","origin","e","modifiedUrl","replace","replacement","from","to","setNodeData","was","attach","document","readyState","traverse","hasMutationObserver","observe","body","childList","subtree","attributes","characterData","attributeFilter","addEventListener","detach","disconnect","map","i","this","MutationObserver","mutations","emitted","mutation","type","attributeName","target","nodeSet","getElementsByTagName","hasURL","collection","nodes","values","nodeName","toLowerCase","length","indexOf","host","Generator","instances","create","Instance","push","detachAll","instance","revert","auto","AUTO_CONFIG_SYNTAX_REGEX","scriptNode","getElementById","nodeData","dataset","autoAffiliate","expressions","match","expression","components","exec","queries","split","trim","reduce","a","b","value","URLSearchParams","isError","textId","console","args","error","data","assign","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call"],"sourceRoot":""}